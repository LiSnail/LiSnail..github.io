<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[并发编程基础]]></title>
    <url>%2F2019%2F09%2F04%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[前言多任务处理，已经是现代计算机必备的功能之一了，有时候使用多线程，不仅仅是计算机的运算能力太强了，还有一个重要的原因是因为计算机运算能力和存储能力的速度上差别太大，导致大量的时间都花费在了磁盘IO、网络通信或者数据库访问。 如果不希望处理器的大部分时间都花费在等待其他资源上，那就必须用一些其他的手段解决运算速度和存取速度差别太大的问题。为了解决此问题，加入一个读写速度和处理器处理速度接近的高速缓存，程序在运行过程中，会将运算需要的数据从主存复制一份到高速缓存当中，处理器进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。 多线程的交互方式在并发编程中，开发人员关心的还是多线程之间的信息交互。在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。 共享内存：共享内存的并发模型是使用比较多的一种模型。这种通讯模型通过设置一个共享变量，线程之间操作同一个变量的方式达到通讯的目的。但是这种模型有线程安全的问题，这样就需要我们在操作共享变量的地方或者代码片段中，显式指定线程之间互斥执行。 消息传递：消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。 在Java中，多线程的通信大部分是通过共享内存，但是线程之间通过写-读内存中的公共状态来隐式进行通信，如何进行公共状态的内存读写操作，我们没办法显式的看到，不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题，所以有必要了解多线程对共享内存是如何操作的。 并发编程中的问题有基础的开发人员应该都知道并发编程中存在的是哪个问题：指令重排序、内存可见性、原子性，所以，为了保证数据的安全，需要满足以下三个特性： 原子性：指在一个操作中，CPU 不可以在中途暂停然后再调度，即不被中断操作，要不执行完成，要不就不执行。 内存可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 有序性：即程序执行的顺序按照代码的先后顺序执行。 怎么解决并发问题为了保证并发编程中，可以满足原子性、可见性和有序性，为了解决高速缓存所带来的缓存一致性以及指令重排序等问题，引入了一个新的概念：内存模型。 内存模型主要就是定义了程序对变量的访问规则，通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。内存模型解决并发问题主要采用两种方式： 限制处理器优化 使用内存屏障]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
</search>
