<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[并发编程基础]]></title>
    <url>%2F2019%2F09%2F04%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[前言并发一直以来是软件开发中比较重要且困难的问题，能写出性能好且正确的并发程序是很难的一件事情，虽然并发编程可以在硬件资源有限的情况下提高系统的性能，但是同时也带来了许多的问题，加大了开发的难度。之所以觉的比较困难，一点是编发编程的复杂性，其次因为我们对并发编程中一些隐式的机制不了解，所以，想要写出正确的并发程序，需要我们多花费一定的时间和精力去好好的学习这方面的内容。并发编程无论是工作中还是面试中，都是比较重要的一块内容，多花费点时间熟练掌握这部分内容，对我们今后的发展都是有一定的帮，接下来就一步一步的来学习。 初识并发我们知道在同一时刻同一个cpu上只能有一个线程在工作，而且处理器的运行计算速度是非常快的，而其他比网络IO、磁盘IO等等，跟处理器的速度比起来是差几个数量级的，导致处理器大量的时间都花费在了等待数据的读写上。所以协调cpu和各个硬件之间的速度差异是非常重要的，要不然cpu就一直在等待，浪费资源。 基于高速缓存的存储交互很好的解决了cpu和内存等其他硬件之间的速度矛盾，每个处理器都有一个自己的高速缓存区域，运行过程中，会将运算需要的数据从主存复制一份到高速缓存当中，处理器进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。 基于高速缓存的这种交互模型，在单核的cpu系统中是没有问题的，但是在多核处理器系统中，每个处理器都有一个自己的高速缓存，当多个处理器同时操作同一块内存的时候,那同步到主内存中的数据以谁为准呢。就会出现一致性的问题。 多线程间如何通信在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。 共享内存：共享内存的模型是使用比较多的一种模型。这种通讯模型通过设置一个共享变量，多线程之间通过操作同一个变量的方式达到通讯的目的。但是这种方式就需要我们在操作共享变量的地方或者代码片段中，显式指定线程之间互斥执行。例如Java中的Sychronized 消息传递：消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。例如Java中典型的消息传递方式就是wait()和notify()。 多线程的通信大部分是通过共享内存，但是线程之间通过写-读内存中的公共状态来隐式进行通信，如何进行公共状态的内存读写操作，我们没办法显式的看到，不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题，所以有必要了解多线程对共享内存是如何操作的。 并发编程中的问题并发编程虽然可以在硬件资源有限的情况下，提升系统的性能，但是也同样带来了很多问题。多处理器系统中，每个处理器都有一个自己的高速缓存，它们又共享同一块主内存，当多个处理器同时操作同一块内存的时候，那同步到主内存中的数据以谁为准呢？这个就是我们所熟知的内存可见性的问题。除此之外还有指令重排序、原子性的问题。所以，为了能保证多线程数据的安全，需要满足以下三个特性： 原子性：一个操作中，CPU不可以在中途暂停然后再调度，即不被中断操作，要不执行完成，要不就不执行。 内存可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 有序性：即程序执行的顺序按照代码的先后顺序执行。 如何解决并发问题为了保证并发编程线程安全问题，解决高速缓存所带来的缓存一致性以及指令重排序等问题，引入了一个新的概念：内存模型。 内存模型主要就是定义了程序对变量的访问规则，通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。内存模型解决并发问题主要采用两种方式：限制处理器优化和使用内存屏障。 后面会专门有一篇文章来详细的说一下内存模型是如何解决并发三问题的。]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
</search>
