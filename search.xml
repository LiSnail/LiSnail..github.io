<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java内存模型]]></title>
    <url>%2F2019%2F09%2F18%2FJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[前言根据java虚拟机规范，java虚拟机管理的内存将分为下面五大区域。 在Java中，所有的实例域、静态域、数组都存放在堆内存中，堆内存是线程之间共享的，通常我们所说线程安全都是指的共享变量（一般指的是成员变量or实例变量、类变量），而局部变量（一般都是类方法中的变量）一般都是存在虚拟机栈中，虚拟机栈是每个线程私有的。所以线程安全问题只发生在成员变量中，局部变量不存在线程安全问题。 1234567891011public class Variable&#123; static int allClicks=0; // 类变量 String str="hello world"; // 实例变量|成员变量 public void method()&#123; int i =0; // 局部变量 &#125;&#125; 什么是Java内存模型Java内存模型（Java Memory Model，JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。 通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。JMM规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存。线程的工作内存中保存了该线程中用到的变量的主内存副本拷贝，线程对共享变量的所有操作都必须在工作内存中进行，不能直接操作主内存变量，而是将变量拷贝到本地内存中，在本地内存操作完成以后，再将结果同步回主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。Java内存模型CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。 并发三问题重排序:指令重排序指的是JIT编译器、cpu处理器和jmm定义的多级缓存存储，在编译字节码和运行机器指令时，在不影响程序最终执行结果的情况下，会对原语句执行的顺序进行优化。 通过下面一段代码来看一下重排序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344private static int x, y;private static int a , b ;public static void main(String[] args) throws InterruptedException &#123; int i = 0; for (; ; ) &#123; i++; x = 0; y = 0; a = 0; b = 0; CountDownLatch latch = new CountDownLatch(1); Thread one = new Thread(() -&gt; &#123; try &#123; latch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; a = 1; x = b; &#125;); Thread other = new Thread(() -&gt; &#123; try &#123; latch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; b = 1; y = a; &#125;); one.start(); other.start(); latch.countDown(); one.join(); other.join(); String result = "第" + i + "次 (" + x + "," + y + "）"; if (x == 0 &amp;&amp; y == 0) &#123; System.err.println(result); break; &#125; else &#123; System.out.println(result); &#125; &#125;&#125; 某时刻,会出现x == y == 0的情况，出现这样的情况，可能是因为一下原因引起的。 编译器优化重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语 句的执行顺序。 如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 内存系统的重排序：处理器使用缓存和读写缓冲区，这使得加载和存储操作看上 去可能是在乱序执行。 可见性线程间的对于共享变量的可见性问题是由多缓存引起的。如果所有处理器公用一个缓存，则不会有这样的问题。现代多核CPU中每个核心拥有自己的缓存，每个核心都会将自己需要的数据读到独占缓存中，数据修改后也是写入到缓存中，然后等待刷入到主存。所以会导致有些核心读取的值是一个过期的值。Java 内存模型屏蔽了这些底层细节，用 JMM 定义了一套读写内存数据的规范，虽然我们不再需要关心缓存，但是JMM抽象了主内存和本地内存的概念。 所有的共享变量存在于主内存中，每个线程有自己的本地内存，线程读写共享数据也是通过本地内存交换的，所以可见性问题依然是存在的。 原子性1234567891011121314151617181920212223242526272829303132public class ConcurrencyTest &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread(); Thread thread = new Thread(myThread, "A"); Thread thread1 = new Thread(myThread, "B"); Thread thread2 = new Thread(myThread, "C"); Thread thread3 = new Thread(myThread, "D"); Thread thread4 = new Thread(myThread, "E"); thread.start(); thread1.start(); thread2.start(); thread3.start(); thread4.start(); &#125;&#125;class MyThread implements Runnable &#123; private int count = 0; public void run() &#123; //synchronized (this) &#123; count++; System.out.println("线程" + Thread.currentThread().getName() + "计算,count=" + count); //&#125; &#125;&#125;运行结果：线程A计算,count=2线程E计算,count=5线程D计算,count=4线程C计算,count=3线程B计算,count=2 上述代码，我们希望的是每个线程对count加1。但是线程A和B的结果相同，显然这不是我们想要的结果。即使我们使用volatile关键字修饰count，也会偶尔出现这样的问题，因为count++ 不是原子操作。count++ 其实等于 count = count + 1 。这也是我们后面会提到的，volatile只能保证有序性以及内存可见性、没有办法保证原子性。如果想要保证原子性，只能通过Synchronized或者concurrent包下的Lock或者原子类Atomic等来保证，这里就不再举例。 java内存模型定义了8种原子操作，来完成内存的操作。 read（读取）：它把一个变量的值从主内存传输到线程的工作内存中，以便以后的load。 load（载入）：把read操作从主内存中的得到的变量值放入到工作内存中的变量副本中 use（使用）：把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值字节码指令时，会使用到这个指令。 assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接受到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时，执行此操作。 store（存储）：作用于工作内存的变量，它把工作内存中一个变量值传送到主内存中，以便随后的write操作使用。 write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量值放入到主内存变量中。 lock（锁定）把变量标识为一条线程独占的状态 unlock（解锁）：把一个处于锁定状态的变量释放出来 内存模型规定，把一个变量从主内存复制到工作内存中，就要顺序的执行read和load操作，如果要把变量同步回主内存，就要顺序的执行store和write操作。需要注意的是，内存模型只规定了顺序执行，但是没有规定两个操作是连续执行。也就是说read 和 load ，store 和 write之间可以插入其他的指令，如对主内存中的变量a、b进行访问，可能出现的顺序是read a、read b、load b、load a。此外的话这8个操作还要满足如下规则。 不允许read、load，store和write操作单一出现。 不允许线程丢弃assign操作，即变量在工作内存中发生改变以后必须同步到主内存。 不允许线程把一个没有进行assign的变量，从工作内存同步到主内存。 一个新的变量只能在主内存中“诞生” 一个成员变量，在同一时刻，只能允许一条线程对其进行lock操作。但是可以被一条线程lock多次。相应的也需要进行相同次数的unlock，此变量才能被解锁。 如果对一个变量进行lock操作，将清空此变量在工作内存中的值。再使用这个变量，需要重新load或者assign。 对一个变量进行unlock之前，必须把工作内存中此变量的值同步回主内存。 以上的8个操作，其中除了lock、unlock操作以外。其余六个是JAVA内存模型来直接保证的原子操作。Java内存模型提供了lock和unlock操作，来开放给使用者直接使用。但是提供了更高的字节码指令，monitorenter和monitorexit来隐式的使用这两个操作。对应到Java中的关键字就是Synchronized。因此，synchronized代码块中的操作也具备原子性。更多细节可以参考JSR133文档。 以上的8中操作，是内存模型规定的原子操作，在Java中，哪些是原子操作呢。 12345int x = 10; //语句1int y = x; //语句2x++; //语句3 x = x + 1; //语句4Object z = new Object();//语句5 这五个操作中，只有语句1是原子操作，语句2的话，其实是先读取x的值，然后再进行赋值，语句3同语句4一样。语句5的话是先开辟一块内存空间，然后进行初始化，将对象的地址引用赋值,也不是原子操作。 也就是说，==只有简单的读取、赋值（而且必须是将确定的值赋给某个变量，变量之间的相互赋值也不是原子操作）才是原子操作==。Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。 Java内存模型如何解决并发问题happen-befor规则参考：深入理解Java内存模型]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程基础]]></title>
    <url>%2F2019%2F09%2F04%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[前言并发一直以来是软件开发中比较重要且困难的问题，能写出性能好且正确的并发程序是很难的一件事情，虽然并发编程可以在硬件资源有限的情况下提高系统的性能，但是同时也带来了许多的问题，加大了开发的难度。之所以觉的比较困难，一点是编发编程的复杂性，其次因为我们对并发编程中一些隐式的机制不了解，所以，想要写出正确的并发程序，需要我们多花费一定的时间和精力去好好的学习这方面的内容。并发编程无论是工作中还是面试中，都是比较重要的一块内容，多花费点时间熟练掌握这部分内容，对我们今后的发展都是有一定的帮，接下来就一步一步的来学习。 初识并发我们知道在同一时刻同一个cpu上只能有一个线程在工作，而且处理器的运行计算速度是非常快的，而其他比网络IO、磁盘IO等等，跟处理器的速度比起来是差几个数量级的，导致处理器大量的时间都花费在了等待数据的读写上。所以协调cpu和各个硬件之间的速度差异是非常重要的，要不然cpu就一直在等待，浪费资源。 基于高速缓存的存储交互很好的解决了cpu和内存等其他硬件之间的速度矛盾，每个处理器都有一个自己的高速缓存区域，运行过程中，会将运算需要的数据从主存复制一份到高速缓存当中，处理器进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。 基于高速缓存的这种交互模型，在单核的cpu系统中是没有问题的，但是在多核处理器系统中，每个处理器都有一个自己的高速缓存，当多个处理器同时操作同一块内存的时候,那同步到主内存中的数据以谁为准呢。就会出现一致性的问题。 多线程间如何通信在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。 共享内存：共享内存的模型是使用比较多的一种模型。这种通讯模型通过设置一个共享变量，多线程之间通过操作同一个变量的方式达到通讯的目的。但是这种方式就需要我们在操作共享变量的地方或者代码片段中，显式指定线程之间互斥执行。例如Java中的Sychronized 消息传递：消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。例如Java中典型的消息传递方式就是wait()和notify()。 多线程的通信大部分是通过共享内存，但是线程之间通过写-读内存中的公共状态来隐式进行通信，如何进行公共状态的内存读写操作，我们没办法显式的看到，不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题，所以有必要了解多线程对共享内存是如何操作的。 并发编程中的问题并发编程虽然可以在硬件资源有限的情况下，提升系统的性能，但是也同样带来了很多问题。多处理器系统中，每个处理器都有一个自己的高速缓存，它们又共享同一块主内存，当多个处理器同时操作同一块内存的时候，那同步到主内存中的数据以谁为准呢？这个就是我们所熟知的内存可见性的问题。除此之外还有指令重排序、原子性的问题。所以，为了能保证多线程数据的安全，需要满足以下三个特性： 原子性：一个操作中，CPU不可以在中途暂停然后再调度，即不被中断操作，要不执行完成，要不就不执行。 内存可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 有序性：即程序执行的顺序按照代码的先后顺序执行。 如何解决并发问题为了保证并发编程线程安全问题，解决高速缓存所带来的缓存一致性以及指令重排序等问题，引入了一个新的概念：内存模型。 内存模型主要就是定义了程序对变量的访问规则，通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。内存模型解决并发问题主要采用两种方式：限制处理器优化和使用内存屏障。 后面会专门有一篇文章来详细的说一下内存模型是如何解决并发三问题的。]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
</search>
